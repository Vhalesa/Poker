To-Do-Liste

Karten:
  - Definition (Datentypen für Farbe, Wert, Karte -> Show, Eq, Ord + evtl Enum, Bounded) [done]
  - Deck (mit allen Karten) [done]
  - Stapel -> Mischfunktion für das Deck [done]

Chips:
  - Datentyp (Show, Ord, Eq) [done]
  - Chipshaufen für jeden Spieler für den Anfang [done]
  - Summe der Chips bilden [done]
  - Wechselfunktion: []
    - reines Wechseln ist fertig [done]
    - Austauschen des Chips (der aus dem Besitz gewechselt wird) mit den gewechselten Chips 
      -> eigenen Chipshaufen aktualisieren []

Regeln:
  - Tabelle mit den Gewinnmöglichkeiten [done]
  - Big Blind, Small Blind [done]
  - Raise []
  - Call []
  - Fold []

Spielablauf (IO?):
  - am Anfang vor allen Spielrunden (vor dem Spiel)
    - Spielern Chipshaufen zuweisen
  - vor der jeder Spielrunde
    - Kartendeck mischen [done]
    - Small/Big Blind zuweisen [done]
  - 4 Wettrunden [] 
    -> Vorgehen bei jeder Wettrunde (Achtung, Pott muss mit übergeben werden) []
      -> (man darf nicht 2x hintereinander erhöhen, ohne das der andere Spieler dazwischen erhöht hat)
      - Small Blind und Big Blind setzen automatisch [done]
      - Small Blind: stockt er auf Big Blind auf, erhöhen oder aufhören []
      - Big Blind: aufstocken, erhöhen oder verlassen []
      - while (beide haben ungleichen Betrag)
        - spielDerDranIst: Raise, Call oder Fold
        - nächsterSpielerDran -> [p1,p2] (p1 war dran, wird wieder ganz hinten eingereiht) 
    - 1. Runde (PreFlop) []
      -> jeder Spieler erhält 2 Karten auf die Hand
    - 2. Runde (Flop) []
      -> 3 Karten werden offen gelegt
    - 3. Runde (Turn Card) []
      -> weitere (4.) Karte wird offen gelegt 
    - 4. Runde []
      -> weitere (5.) Karte wird offen gelegt
  - Showdown []
    - Spieler (4.Runde als letzter erhöht / Small Blind) muss seine Combo vorzeigen
    - anderer Spieler darf
    - Berechnung/Vergleich wer gewonnen hat -> CompareFunktion []
      -> überprüfen, was genau Combo.hs kann (vielleicht geht es automatisch?)
      -> bekommt 2 Combos => gibt das höhere aus(?), und/oder den Player, der gewonnen hat
      -> dazu vielleicht die Combo in Player speichern?
    - Verteilung des ChipsGewinns
  - nach jeder Spielrunde
    - Spieler hat die Möglichkeit aufzuhören
    - automatisches Ende, wenn einer zu wenig Chips/Geld hat

Mensch: []
- Abfrage, was er tun will (Call, Raise, Fold) []
  -> bei Raise noch zusätzlich: um wie viel? 5,10,15 ....AllIn
- nach jedem Spiel: weiterspielen? []

KI:
- Anfang: Rudimentäre KI? (Random könnte kompliziert werden...)
    -> KI kann Call, Raise, Fold, AllIn []
    -> KI kann ihre Menge an Chips auslesen []
    -> KI macht immer das gleiche (immer call z.B.) []
    -> KI kann durcheinander Call, Raise, Fold und AllIn []
- Später: KI macht intelligente Züge 
    -> KI berechnet ihr momentanes Blatt []
    -> KI berechnet die Wahrscheinlichkeit, dass sie damit gewinnt []
    -> KI berechnet die Wahrscheinlichkeit, dass ihr Blatt noch besser wird []
    -> KI macht Berechnungen parallel (Awesome Vorlesungstechnik) []
    -> KI verwendet ihre Berechnungen um zu entscheiden, ob sie Call, Raise, Fold oder AllIn macht []
    -> KI kann bluffen []

Text-Ausgabe:
  - Kartensymbole wenn möglich in bunt (rot/schwarz) []
    -> wird schwer, da es auf dem Cip-Pool das entsprechende Modul fehlt

Allgemeine Anforderungen:
- mind. 2 (oder 3) Themen aus der Vorlesung verwenden
  - z.B. Parallelität, Nebenläufigkeit, (Lazyness?) bei der KI
  - evtl. GUI
  - generell IO für Ein- und Ausgabe

- für Präsentation:
  - welche Techniken aus der Vorlesung wurden wo angewendet?
  - welche interessanten Probleme traten auf? - wie wurden sie gelöst?
  - welche Bibliotheken/Codevorlagen wurden genutzt?

- Probleme:
  - randomFunktion: Funktionen sollten ohne IO funktionieren, allerdings
    muss mind. 1 Zufallszahl über IO erzeugt werden. Diese würde dann
    alles vom Type IO machen -> doof
    Lösung: StdGenerator wird über diese eine IO-RandomZahl erzeugt,
            dieser kann dann Int-Zufallszahlen erzeugen (ohne IO)
  - Straight erstellen/herausfinden: Card ist nicht vom Typ Enum,
    und Ace ist sowohl höchste als auch niedrigste Karte
    Lösung: Value von Card zur Überprüfung verwenden, da Enum.
            (+ extra pred-Funktion damit Ace beides ist)
