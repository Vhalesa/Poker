To-Do-Liste

Karten: [done]
  - Definition (Datentypen für Farbe, Wert, Karte -> Show, Eq, Ord + evtl Enum, Bounded) [done]
  - Deck (mit allen Karten) [done]
  - Stapel -> Mischfunktion für das Deck [done]

Chips: => abgeschafft!
  - Datentyp (Show, Ord, Eq) [done]
  - Chipshaufen für jeden Spieler für den Anfang [done]
  - Summe der Chips bilden [done]
  - Wechselfunktion:
    - reines Wechseln ist fertig [done]
    - Austauschen des Chips (der aus dem Besitz gewechselt wird) mit den gewechselten Chips 
      -> eigenen Chipshaufen aktualisieren

Regeln: [done]
  - Tabelle mit den Gewinnmöglichkeiten [done]
  - Big Blind, Small Blind [done]
  - Raise [done]
  - Call [done]
    Absicherung, bei nicht genug Geld -> automatisch AllIn -> anderer Spieler bekommt überschüssiges Geld zurück
  - AllIn [done]
    alle Karten aufdecken [done]
    showDown [done]
  - Fold [done]

Spielablauf (IO?):[done]
  - am Anfang vor allen Spielrunden (vor dem Spiel)
    - Spielern Geld zuweisen [done]
  - vor der jeder Spielrunde
    - Kartendeck mischen [done]
    - Small/Big Blind zuweisen [done]
  - 4 Wettrunden [done]
    -> ERSTE Wettrunde: Reihenfolge: ...,Dealer, Small, Big [done]
    -> ZWEITE - VIERTE Wettrunde: Reihenfolge: Small, Big, ..., Dealer [done]
    -> Vorgehen bei jeder Wettrunde (Achtung, Pott muss mit übergeben werden) [done]
      -> Wenn alle Spieler außer einem fold gemacht haben, abbrechen und direkt verbleibenden Spieler zum Gewinner erklären [done]
      -> (man darf nicht 2x hintereinander erhöhen, ohne das der andere Spieler dazwischen erhöht hat)
      - Small Blind und Big Blind setzen automatisch [done]
      - Small Blind: stockt er auf Big Blind auf, erhöhen oder aufhören [done]
      - Big Blind: aufstocken, erhöhen oder verlassen [done]
      - while (beide haben ungleichen Betrag)
        - spielDerDranIst: Raise, Call oder Fold [done]
            -> Fold:
                - Spieler temporär aus der Spielerliste löschen und am Ende nach dem Showdown wieder einsetzen? [zu anstrengend]
                - Hand des Spielers auf [] setzen? [machen wir nicht so]
                - Spieler eine Bool Variable geben namens Fold? [done]
        - nächsterSpielerDran -> [p1,p2] (p1 war dran, wird wieder ganz hinten eingereiht) 
    - 1. Runde (PreFlop) [done]
      -> jeder Spieler erhält 2 Karten auf die Hand
    - 2. Runde (Flop) [done]
      -> 3 Karten werden offen gelegt
    - 3. Runde (Turn Card) [done]
      -> weitere (4.) Karte wird offen gelegt 
    - 4. Runde [done]
      -> weitere (5.) Karte wird offen gelegt
  - Showdown [done]
    - Spieler (4.Runde als letzter erhöht / Small Blind) muss seine Combo vorzeigen [done]
      -> Im Moment wird einfach für alle, die noch dabei sind, ausgewertet und nur die Gewinner-Kombo angezeigt [done]
    - anderer Spieler darf
    - Berechnung/Vergleich wer gewonnen hat -> CompareFunktion [done]
      -> (vielleicht geht es automatisch?) [done]
      -> bekommt Combos => gibt das höchste aus(?), und/oder den Player, der gewonnen hat [done]
      -> dazu vielleicht die Combo in Player speichern? [done]
    - Verteilung des ChipsGewinns [done]
  - nach jeder Spielrunde [done]
    - Spieler hat die Möglichkeit aufzuhören [done]
    - automatisches Ende, wenn einer keine Chips mehr hat [done] 
    - Reset von Pot, Karten, Combo, CurrentBet [done]
  - nach n Spielrunden (Wenn jeder Spieler einmal Big Blind war)
    - Blinds werden erhoeht [done]

Mensch: [done]
- In neues Modul, da Game bereits sehr groß? [done]
- Abfrage, was er tun will (Call, Raise, Fold) [done]
  -> bei Raise noch zusätzlich: um wie viel? 5,10,15 ....AllIn 
  -> sowas wie raise 200 soll gehen [done]
- nach jedem Spiel: weiterspielen? [done]

KI:
- In neues Modul, da Game bereits sehr groß? [done]
- Anfang: Rudimentäre KI? (Random könnte kompliziert werden...)
    -> KI kann Call, Raise, Fold, AllIn [done]
    -> KI kann ihre Menge an Chips auslesen [done]
    -> KI macht immer das gleiche (immer call z.B.) [done]
    -> KI kann durcheinander Call, Raise, Fold und AllIn [done]
- Später: KI macht intelligente Züge 
    -> KI berechnet ihr momentanes Blatt [done]
    -> KI berechnet die Wahrscheinlichkeit, dass sie damit gewinnt []
    -> KI berechnet die Wahrscheinlichkeit, dass ihr Blatt noch besser wird [done]
    -> KI macht Berechnungen nebenläufig (Awesome Vorlesungstechnik) [done]
    -> KI verwendet ihre Berechnungen um zu entscheiden, ob sie Call, Raise, Fold oder AllIn macht [done]
    -> KI kann bluffen []

Text-Ausgabe: []
  - Kartensymbole wenn möglich in bunt (rot/schwarz) [done]
  - Ausgabe generell schöner machen. Fragen vielleicht in fett oder so []
  - Ausgabe langsamer, nicht alles auf einmal. Aber nicht so wichtig. [done]
  - Ausgaben augräumen [done]
  - Poker-Spiel-Blink-Dings ganz an den Anfang, vor Spieleranzahl-Auswahl[done]

Allgemeine Anforderungen:
- mind. 2 (oder 3) Themen aus der Vorlesung verwenden
  - z.B. Parallelität, Nebenläufigkeit [drin], (Lazyness?) bei der KI
  - Mehrere KIs später (?), dann parallele und nebenläufige Berechnungen? 
  - evtl. GUI
  - generell IO für Ein- und Ausgabe [drin]

- für Präsentation:
  - welche Techniken aus der Vorlesung wurden wo angewendet?
    * IO (zum Ausgeben der Information für den Spieler, Abfrage der Eingabe des Spielers)
    * generell Monaden/monadische Funktionen
    * Nebenläufigkeit mit STM (für die Berechnungen der KI)
    * Record-Syntax (für den Spieler Datentyp)
  - welche interessanten Probleme traten auf? - wie wurden sie gelöst?
  - welche Bibliotheken/Codevorlagen wurden genutzt?

- Probleme:
  - randomFunktion: Funktionen sollten ohne IO funktionieren, allerdings
    muss mind. 1 Zufallszahl über IO erzeugt werden. Diese würde dann
    alles vom Type IO machen -> doof
    Lösung: StdGenerator wird über diese eine IO-RandomZahl erzeugt,
            dieser kann dann Int-Zufallszahlen erzeugen (ohne IO)
  - Straight erstellen/herausfinden: Card ist nicht vom Typ Enum,
    und Ace ist sowohl höchste als auch niedrigste Karte
    Lösung: Value von Card zur Überprüfung verwenden, da Enum.
            (+ extra pred-Funktion damit Ace beides ist)
  - Chips Datentyp erwies sich im Nachhinein als nicht praktikabel
    Lösung: Chips Datentyp wurde wieder entfernt und stattdessen Int verwendet
  - generell gibt es einige Sonderfälle, die man beachten muss. Nicht wirklich
    ein Problem, aber die Funktionen mussten doch oft etwas abgeändert werden
    oder nachträglich noch etwas eingefügt werden.
  - Control.Concurrent.STM war auf dem Cip-Pool nicht installiert.
    -> cabal install stm
  - Control.Concurrent.Thread.Delay muss auch auf dem Cip-Pool installiert werden
    -> cabal install concurrent-extra

- Verwendete Bibliotheken
  - Data.List (Um Listen zu sortieren)
  - System.Random (Für die Mischfunktion und random Geld setzen)
  - Control.Monad (Für when-Abfragen)
  - Control.Concurrent.STM und Control.Concurrent für Nebenläufigkeit
  - Control.Concurrent.Thread.Delay für verzögerte Ausgabe
